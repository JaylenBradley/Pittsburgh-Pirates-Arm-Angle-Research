"""
Generate Summary Statistics Script for Baseball Pitcher Pose Analysis

This script computes summary statistics from the results CSV generated by generate_results_csv.py
and optionally creates visualizations (histograms) of error distributions.

Summary Statistics Calculated:
- MAE (Mean Absolute Error) using closest prediction
- MAE using average prediction
- Standard Deviation of Ground Truth angles
- Standard Deviation of Closest Prediction angles
- Standard Deviation of Average Prediction angles
- Standard Deviation of Absolute Errors (Closest)
- Standard Deviation of Absolute Errors (Average)
- % Predictions Above Ground Truth
- % Predictions Below Ground Truth
- % Within 3 Degrees of Ground Truth
- % Within ~8 Degrees of Ground Truth

Usage:
    From Pirates_Arm_Angle directory:
    python scripts/generate_summary_statistics.py [OPTIONS]

Arguments:
    --input PATH: Input results CSV path (default: baseball_vids/data_analysis/results.csv)
    --output PATH: Output summary CSV path (default: baseball_vids/data_analysis/summary_statistics.csv)
    --plot: Generate error distribution plots
    --plot-format FORMAT: Plot file format (default: png, options: png, pdf, svg, jpg)
    --bins NUMBER: Number of bins for histograms (default: 20)
    --bin-width FLOAT: Bin width for histograms (overrides --bins if specified)
    --force: Force regeneration even if output exists

Examples:
    python scripts/generate_summary_statistics.py
    python scripts/generate_summary_statistics.py --plot
    python scripts/generate_summary_statistics.py --plot --plot-format pdf --bins 30
"""

import sys
import csv
import math
from pathlib import Path
from argparse import ArgumentParser
import warnings

# Try to import matplotlib for plotting
try:
    import matplotlib

    matplotlib.use('Agg')  # Non-interactive backend
    import matplotlib.pyplot as plt
    import numpy as np

    MATPLOTLIB_AVAILABLE = True
except ImportError:
    MATPLOTLIB_AVAILABLE = False
    warnings.warn("Matplotlib not available. Plotting will be disabled.")

# Import our utilities
import pose_utils


def load_results_csv(csv_path):
    """
    Load results CSV file.

    Args:
        csv_path: Path to results CSV file

    Returns:
        List of dictionaries with frame data
    """
    results = []

    with open(csv_path, 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            results.append(row)

    return results


def extract_angle_data(results):
    """
    Extract valid angle data from results.

    Args:
        results: List of result dictionaries

    Returns:
        Dictionary with shoulder and elbow angle data
    """
    shoulder_data = []
    elbow_data = []

    for row in results:
        video_id = row['video_id']
        frame_name = row['frame_name']

        # Get ground truth
        try:
            ground_truth = float(row['ground_truth_angle'])
        except (ValueError, KeyError):
            continue

        # Get shoulder-wrist angle
        shoulder_angle_str = row.get('pitcher_angle_shoulder_wrist', 'N/A')
        if shoulder_angle_str != 'N/A':
            try:
                shoulder_angle = float(shoulder_angle_str)
                shoulder_data.append({
                    'video_id': video_id,
                    'frame_name': frame_name,
                    'predicted_angle': shoulder_angle,
                    'ground_truth': ground_truth,
                    'error': abs(shoulder_angle - ground_truth)
                })
            except ValueError:
                pass

        # Get elbow-wrist angle
        elbow_angle_str = row.get('pitcher_angle_elbow_wrist', 'N/A')
        if elbow_angle_str != 'N/A':
            try:
                elbow_angle = float(elbow_angle_str)
                elbow_data.append({
                    'video_id': video_id,
                    'frame_name': frame_name,
                    'predicted_angle': elbow_angle,
                    'ground_truth': ground_truth,
                    'error': abs(elbow_angle - ground_truth)
                })
            except ValueError:
                pass

    return {
        'shoulder': shoulder_data,
        'elbow': elbow_data
    }


def compute_video_averages(angle_data):
    """
    Compute average prediction per video for average prediction metrics.

    Args:
        angle_data: List of angle data dictionaries

    Returns:
        Dictionary mapping video_id to average predicted angle
    """
    video_angles = {}

    for entry in angle_data:
        video_id = entry['video_id']
        if video_id not in video_angles:
            video_angles[video_id] = []
        video_angles[video_id].append(entry['predicted_angle'])

    # Compute averages
    video_averages = {}
    for video_id, angles in video_angles.items():
        video_averages[video_id] = sum(angles) / len(angles)

    return video_averages


def calculate_summary_statistics(angle_data, angle_type='shoulder'):
    """
    Calculate summary statistics for angle data.

    Args:
        angle_data: List of angle data dictionaries
        angle_type: 'shoulder' or 'elbow'

    Returns:
        Dictionary with summary statistics
    """
    if not angle_data:
        return None

    # Extract values
    predicted_angles = [entry['predicted_angle'] for entry in angle_data]
    ground_truths = [entry['ground_truth'] for entry in angle_data]
    errors = [entry['error'] for entry in angle_data]

    # MAE using closest prediction (per frame)
    mae_closest = sum(errors) / len(errors)

    # Compute average predictions per video
    video_averages = compute_video_averages(angle_data)

    # MAE using average prediction (per video)
    video_ground_truths = {}
    for entry in angle_data:
        video_id = entry['video_id']
        if video_id not in video_ground_truths:
            video_ground_truths[video_id] = entry['ground_truth']

    average_errors = []
    for video_id, avg_pred in video_averages.items():
        gt = video_ground_truths[video_id]
        average_errors.append(abs(avg_pred - gt))

    mae_average = sum(average_errors) / len(average_errors) if average_errors else 0

    # Standard deviations
    def std_dev(values):
        if len(values) < 2:
            return 0
        mean = sum(values) / len(values)
        variance = sum((x - mean) ** 2 for x in values) / (len(values) - 1)
        return math.sqrt(variance)

    std_ground_truth = std_dev(ground_truths)
    std_closest_pred = std_dev(predicted_angles)
    std_ae_closest = std_dev(errors)
    std_ae_average = std_dev(average_errors) if average_errors else 0

    # Average prediction standard deviation (using video averages)
    avg_pred_values = list(video_averages.values())
    std_average_pred = std_dev(avg_pred_values) if len(avg_pred_values) >= 2 else 0

    # Percentage metrics (using closest prediction)
    above_gt = sum(1 for entry in angle_data if entry['predicted_angle'] > entry['ground_truth'])
    below_gt = sum(1 for entry in angle_data if entry['predicted_angle'] < entry['ground_truth'])
    within_3 = sum(1 for entry in angle_data if entry['error'] <= 3.0)
    within_8 = sum(1 for entry in angle_data if entry['error'] <= 8.0)

    total = len(angle_data)
    pct_above = (above_gt / total) * 100
    pct_below = (below_gt / total) * 100
    pct_within_3 = (within_3 / total) * 100
    pct_within_8 = (within_8 / total) * 100

    return {
        'angle_type': angle_type,
        'n_frames': total,
        'n_videos': len(video_averages),
        'mae_closest': mae_closest,
        'mae_average': mae_average,
        'std_ground_truth': std_ground_truth,
        'std_closest_prediction': std_closest_pred,
        'std_average_prediction': std_average_pred,
        'std_ae_closest': std_ae_closest,
        'std_ae_average': std_ae_average,
        'pct_above_gt': pct_above,
        'pct_below_gt': pct_below,
        'pct_within_3_degrees': pct_within_3,
        'pct_within_8_degrees': pct_within_8,
        'errors': errors  # For plotting
    }


def write_summary_csv(shoulder_stats, elbow_stats, output_path):
    """
    Write summary statistics to CSV file.

    Args:
        shoulder_stats: Dictionary with shoulder statistics (or None)
        elbow_stats: Dictionary with elbow statistics (or None)
        output_path: Path to output CSV file
    """
    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    fieldnames = [
        'angle_type',
        'n_frames',
        'n_videos',
        'mae_closest',
        'mae_average',
        'std_ground_truth',
        'std_closest_prediction',
        'std_average_prediction',
        'std_ae_closest',
        'std_ae_average',
        'pct_above_gt',
        'pct_below_gt',
        'pct_within_3_degrees',
        'pct_within_8_degrees'
    ]

    with open(output_path, 'w', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()

        for stats in [shoulder_stats, elbow_stats]:
            if stats:
                # Remove 'errors' key before writing
                row = {k: v for k, v in stats.items() if k != 'errors'}
                writer.writerow(row)

    print(f"✓ Summary statistics saved to: {output_path}")


def plot_error_distribution(shoulder_stats, elbow_stats, output_dir, plot_format='png',
                            bins=20, bin_width=None):
    """
    Create histograms of error distributions.

    Args:
        shoulder_stats: Dictionary with shoulder statistics (or None)
        elbow_stats: Dictionary with elbow statistics (or None)
        output_dir: Directory to save plots
        plot_format: File format for plots (png, pdf, svg, jpg)
        bins: Number of bins for histogram
        bin_width: Bin width (overrides bins if specified)
    """
    if not MATPLOTLIB_AVAILABLE:
        print("✗ Matplotlib not available. Cannot generate plots.")
        return

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    stats_list = []
    if shoulder_stats:
        stats_list.append(('shoulder', shoulder_stats))
    if elbow_stats:
        stats_list.append(('elbow', elbow_stats))

    if not stats_list:
        print("No data to plot.")
        return

    for angle_type, stats in stats_list:
        errors = stats['errors']

        if not errors:
            continue

        # Create figure
        fig, ax = plt.subplots(figsize=(10, 6))

        # Determine bins
        if bin_width:
            max_error = max(errors)
            bins_array = np.arange(0, max_error + bin_width, bin_width)
        else:
            bins_array = bins

        # Plot histogram
        ax.hist(errors, bins=bins_array, edgecolor='black', alpha=0.7, color='steelblue')

        # Add vertical lines for MAE
        mae = stats['mae_closest']
        ax.axvline(mae, color='red', linestyle='--', linewidth=2, label=f'MAE: {mae:.2f}°')

        # Labels and title
        ax.set_xlabel('Absolute Error (degrees)', fontsize=12)
        ax.set_ylabel('Frequency', fontsize=12)
        ax.set_title(f'Error Distribution: {angle_type.capitalize()}-to-Wrist Angle\n'
                     f'(n={stats["n_frames"]} frames from {stats["n_videos"]} videos)',
                     fontsize=14, fontweight='bold')
        ax.legend(fontsize=10)
        ax.grid(True, alpha=0.3)

        # Save plot
        output_file = output_dir / f'error_distribution_{angle_type}.{plot_format}'
        plt.tight_layout()
        plt.savefig(output_file, dpi=300, bbox_inches='tight')
        plt.close()

        print(f"✓ Plot saved: {output_file}")


def main():
    parser = ArgumentParser(
        description="Generate summary statistics and optional visualizations"
    )
    parser.add_argument(
        "--input",
        type=str,
        default=None,
        help="Input results CSV path (default: baseball_vids/data_analysis/results.csv)"
    )
    parser.add_argument(
        "--output",
        type=str,
        default=None,
        help="Output summary CSV path (default: baseball_vids/data_analysis/summary_statistics.csv)"
    )
    parser.add_argument(
        "--plot",
        action="store_true",
        help="Generate error distribution plots"
    )
    parser.add_argument(
        "--plot-format",
        type=str,
        default="png",
        choices=["png", "pdf", "svg", "jpg"],
        help="Plot file format (default: png)"
    )
    parser.add_argument(
        "--bins",
        type=int,
        default=20,
        help="Number of bins for histograms (default: 20)"
    )
    parser.add_argument(
        "--bin-width",
        type=float,
        default=None,
        help="Bin width for histograms (overrides --bins if specified)"
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Force regeneration even if output exists"
    )

    args = parser.parse_args()

    # Get baseball_vids directory for default paths
    try:
        baseball_vids_dir = pose_utils.get_baseball_vids_dir()
    except FileNotFoundError as e:
        print(f"Error: {e}")
        sys.exit(1)

    # Get input path
    if args.input:
        input_path = Path(args.input)
    else:
        input_path = baseball_vids_dir / "data_analysis" / "results.csv"

    if not input_path.exists():
        print(f"Error: Input CSV not found: {input_path}")
        print("  Make sure you've run generate_results_csv.py first.")
        sys.exit(1)

    # Get output path
    if args.output:
        output_path = Path(args.output)
    else:
        output_path = baseball_vids_dir / "data_analysis" / "summary_statistics.csv"

    # Check if output already exists
    if output_path.exists() and not args.force:
        print(f"Output file already exists: {output_path}")
        print("Use --force to regenerate")
        sys.exit(0)

    print(f"\nInput CSV: {input_path}")
    print(f"Output CSV: {output_path}")
    if args.plot:
        plots_dir = output_path.parent / "plots"
        print(f"Plots directory: {plots_dir}")
    print()

    # Load results
    print("Loading results CSV...")
    results = load_results_csv(input_path)
    print(f"✓ Loaded {len(results)} frame(s)")

    # Extract angle data
    print("Extracting angle data...")
    angle_data = extract_angle_data(results)

    shoulder_data = angle_data['shoulder']
    elbow_data = angle_data['elbow']

    print(f"✓ Found {len(shoulder_data)} shoulder-wrist calculation(s)")
    print(f"✓ Found {len(elbow_data)} elbow-wrist calculation(s)")

    if not shoulder_data and not elbow_data:
        print("\n✗ No valid angle data found!")
        sys.exit(1)

    # Calculate statistics
    print("\nCalculating summary statistics...")

    shoulder_stats = None
    elbow_stats = None

    if shoulder_data:
        shoulder_stats = calculate_summary_statistics(shoulder_data, 'shoulder')
        print(f"✓ Calculated shoulder-wrist statistics")

    if elbow_data:
        elbow_stats = calculate_summary_statistics(elbow_data, 'elbow')
        print(f"✓ Calculated elbow-wrist statistics")

    # Write summary CSV
    print("\nWriting summary CSV...")
    write_summary_csv(shoulder_stats, elbow_stats, output_path)

    # Print statistics to terminal
    print(f"\n{'=' * 50}")
    print(f"SUMMARY STATISTICS")
    print(f"{'=' * 50}")

    for stats in [shoulder_stats, elbow_stats]:
        if not stats:
            continue

        print(f"\n{stats['angle_type'].upper()}-TO-WRIST ANGLE:")
        print(f"  Frames: {stats['n_frames']}")
        print(f"  Videos: {stats['n_videos']}")
        print(f"\n  MAE (Closest Prediction):  {stats['mae_closest']:.3f}°")
        print(f"  MAE (Average Prediction):  {stats['mae_average']:.3f}°")
        print(f"\n  Std Dev (Ground Truth):           {stats['std_ground_truth']:.3f}°")
        print(f"  Std Dev (Closest Prediction):     {stats['std_closest_prediction']:.3f}°")
        print(f"  Std Dev (Average Prediction):     {stats['std_average_prediction']:.3f}°")
        print(f"  Std Dev (Abs Error - Closest):    {stats['std_ae_closest']:.3f}°")
        print(f"  Std Dev (Abs Error - Average):    {stats['std_ae_average']:.3f}°")
        print(f"\n  % Predictions Above GT:    {stats['pct_above_gt']:.1f}%")
        print(f"  % Predictions Below GT:    {stats['pct_below_gt']:.1f}%")
        print(f"  % Within 3 Degrees:        {stats['pct_within_3_degrees']:.1f}%")
        print(f"  % Within 8 Degrees:        {stats['pct_within_8_degrees']:.1f}%")

    print(f"{'=' * 50}\n")

    # Generate plots if requested
    if args.plot:
        print("Generating plots...")
        plots_dir = output_path.parent / "plots"
        plot_error_distribution(
            shoulder_stats, elbow_stats, plots_dir,
            plot_format=args.plot_format,
            bins=args.bins,
            bin_width=args.bin_width
        )
        print()


if __name__ == "__main__":
    main()